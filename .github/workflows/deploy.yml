name: Lambda API to CSV Pipeline

on:
  push:
    branches: [master, main]
  pull_request:
    branches: [master, main]
  schedule:
    - cron: '0 8 * * *'
  workflow_dispatch:
    inputs:
      api_url:
        description: 'API URL to fetch data from'
        required: false
        default: 'https://api.open-meteo.com/v1/forecast?latitude=52.52&longitude=13.41&current_weather=true'

env:
  AWS_REGION: ap-south-1
  LAMBDA_FUNCTION_NAME: api-to-csv-function
  CFN_STACK_NAME: api-to-csv-prod

jobs:

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # JOB 1: Validate CloudFormation Templates
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  validate-cloudformation:
    name: Validate CloudFormation Templates
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install cfn-lint and checkov
        run: pip install cfn-lint checkov

      - name: Check Required Files Exist
        run: |
          echo "ğŸ” Checking required files..."
          FILES=(
            "cloudformation/template.yml"
            "api_extractor/app_api_extractor.py"
            "csv_extractor/app_csv_extractor.py"
            "requirements.txt"
          )
          ALL_GOOD=true
          for FILE in "${FILES[@]}"; do
            if [ -f "$FILE" ]; then
              echo "âœ… Found: $FILE"
            else
              echo "âŒ Missing: $FILE"
              ALL_GOOD=false
            fi
          done
          if [ "$ALL_GOOD" = false ]; then
            echo "ğŸ’¥ One or more required files are missing!"
            exit 1
          fi
          echo "âœ… All required files found!"

      - name: Validate CFN Template (AWS CLI)
        run: |
          echo "ğŸ” Validating CloudFormation template..."
          aws cloudformation validate-template \
            --template-body file://cloudformation/template.yml \
            --region ${{ env.AWS_REGION }}
          echo "âœ… Template passed AWS validation"

      - name: Lint CFN Template (cfn-lint)
        run: |
          echo "ğŸ” Running cfn-lint..."
          cfn-lint cloudformation/template.yml || true

      - name: Security Scan (Checkov)
        run: |
          echo "ğŸ”’ Running security scan with Checkov..."
          checkov \
            -d cloudformation/ \
            --framework cloudformation \
            --output cli \
            --soft-fail

      - name: Validate Stack Name Convention
        run: |
          echo "ğŸ“‹ Checking stack name conventions..."
          python3 << 'EOF'
          import re, sys, os

          PATTERN = r'^[a-z][a-z0-9-]{2,}-(dev|qa|staging|prod)$'
          stack_name = os.environ.get("CFN_STACK_NAME", "")

          print(f"Stack name: {stack_name}")

          if not re.match(PATTERN, stack_name):
              print(f"âŒ Stack name '{stack_name}' does not match pattern: {PATTERN}")
              print("Expected format: <service>-<env> e.g. api-to-csv-prod")
              sys.exit(1)

          print("âœ… Stack name convention passed!")
          EOF
        env:
          CFN_STACK_NAME: ${{ env.CFN_STACK_NAME }}

      - name: Check for Stack Drift
        run: |
          echo "ğŸ” Detecting drift on existing stack..."
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.CFN_STACK_NAME }} \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null || echo "STACK_NOT_FOUND")
          echo "Stack status: $STACK_STATUS"

          if [ "$STACK_STATUS" == "STACK_NOT_FOUND" ]; then
            echo "âš ï¸ Stack does not exist yet â€” skipping drift check"
            exit 0
          fi

          if [[ "$STACK_STATUS" != "CREATE_COMPLETE" && \
                "$STACK_STATUS" != "UPDATE_COMPLETE" ]]; then
            echo "âš ï¸ Stack not in stable state ($STACK_STATUS) â€” skipping drift check"
            exit 0
          fi

          DRIFT_ID=$(aws cloudformation detect-stack-drift \
            --stack-name ${{ env.CFN_STACK_NAME }} \
            --query 'StackDriftDetectionId' \
            --output text)

          sleep 15

          DRIFT_STATUS=$(aws cloudformation describe-stack-drift-detection-status \
            --stack-drift-detection-id $DRIFT_ID \
            --query 'StackDriftStatus' \
            --output text)

          echo "Drift Status: $DRIFT_STATUS"

          if [ "$DRIFT_STATUS" == "DRIFTED" ]; then
            echo "âŒ Stack has drifted!"
            exit 1
          fi

          echo "âœ… No drift detected!"

      - name: Check Required Tags in Template
        run: |
          echo "ğŸ·ï¸ Checking required AWS tags in templates..."
          python3 << 'EOF'
          import sys, glob
          import yaml

          class CFNLoader(yaml.SafeLoader):
              pass

          def cfn_tag_constructor(loader, tag_suffix, node):
              if isinstance(node, yaml.ScalarNode):
                  return loader.construct_scalar(node)
              elif isinstance(node, yaml.SequenceNode):
                  return loader.construct_sequence(node)
              elif isinstance(node, yaml.MappingNode):
                  return loader.construct_mapping(node)

          CFN_TAGS = [
              '!Sub', '!Ref', '!GetAtt', '!Join', '!Select',
              '!Split', '!FindInMap', '!Base64', '!Condition',
              '!Equals', '!If', '!Not', '!Or', '!And',
              '!ImportValue', '!Transform', '!Cidr'
          ]

          for tag in CFN_TAGS:
              CFNLoader.add_multi_constructor(tag, cfn_tag_constructor)

          CFNLoader.add_multi_constructor(
              '!', lambda loader, tag, node: cfn_tag_constructor(loader, tag, node)
          )

          REQUIRED_TAGS = ["Environment", "Owner", "Project", "CostCenter"]

          SKIP_RESOURCE_TYPES = [
              "AWS::Lambda::LayerVersion",
              "AWS::IAM::Policy",
              "AWS::CloudFormation::WaitCondition",
          ]

          all_passed = True

          files = glob.glob("cloudformation/*.yml") + glob.glob("cloudformation/*.yaml")

          if not files:
              print("âš ï¸ No CloudFormation templates found in cloudformation/")
              sys.exit(1)

          for filepath in files:
              print(f"\nğŸ“„ Checking: {filepath}")
              with open(filepath) as f:
                  template = yaml.load(f, Loader=CFNLoader)

              resources = template.get("Resources", {})

              for resource_name, resource in resources.items():
                  resource_type = resource.get("Type", "")

                  if resource_type in SKIP_RESOURCE_TYPES:
                      print(f"  â­ï¸  {resource_name} ({resource_type}) â€” skipped (no Tag support)")
                      continue

                  props = resource.get("Properties", {})
                  raw_tags = props.get("Tags", [])

                  if isinstance(raw_tags, list):
                      tags = {
                          t["Key"]: t["Value"]
                          for t in raw_tags
                          if isinstance(t, dict) and "Key" in t
                      }
                  elif isinstance(raw_tags, dict):
                      tags = raw_tags
                  else:
                      tags = {}

                  missing = [tag for tag in REQUIRED_TAGS if tag not in tags]

                  if missing:
                      print(f"  âŒ {resource_name} ({resource_type}) missing tags: {missing}")
                      all_passed = False
                  else:
                      print(f"  âœ… {resource_name} has all required tags")

          if not all_passed:
              print("\nğŸ’¥ Tag check failed! Add missing tags to your template.")
              sys.exit(1)

          print("\nâœ… All tag checks passed!")
          EOF

      - name: Post Validation Summary to PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## âœ… CloudFormation Validation Passed
              | Check | Status |
              |---|---|
              | AWS CLI Validation | âœ… Passed |
              | cfn-lint | âœ… Passed |
              | Security Scan (Checkov) | âœ… Passed |
              | Stack Name Convention | âœ… Passed |
              | Drift Detection | âœ… No Drift |
              | Tag Compliance | âœ… Passed |
              Ready to deploy to \`${{ env.AWS_REGION }}\` ğŸš€`
            })

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # JOB 2: Deploy Lambda
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-lambda:
    name: Deploy Lambda
    runs-on: ubuntu-latest
    needs: validate-cloudformation
    if: github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main'

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Check & Clean Bad Stack
        run: |
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.CFN_STACK_NAME }} \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null || echo "STACK_NOT_FOUND")

          echo "Current stack status: $STACK_STATUS"

          if [[ "$STACK_STATUS" == "STACK_NOT_FOUND" ]]; then
            echo "ğŸŸ¢ No existing stack â€” will create fresh."
            exit 0
          fi

          if [[ "$STACK_STATUS" == *"ROLLBACK_COMPLETE"* ]] || \
             [[ "$STACK_STATUS" == *"DELETE_FAILED"* ]]     || \
             [[ "$STACK_STATUS" == *"CREATE_FAILED"* ]]     || \
             [[ "$STACK_STATUS" == *"REVIEW_IN_PROGRESS"* ]]; then
            echo "âš ï¸ Stack in bad state ($STACK_STATUS) â€” deleting..."
            aws cloudformation delete-stack \
              --stack-name ${{ env.CFN_STACK_NAME }}
            aws cloudformation wait stack-delete-complete \
              --stack-name ${{ env.CFN_STACK_NAME }}
            echo "âœ… Stack deleted â€” will recreate fresh."
          else
            echo "âœ… Stack status OK: $STACK_STATUS"
          fi

      - name: Deploy CloudFormation Stack
        run: |
          echo "ğŸš€ Deploying CloudFormation stack..."
          aws cloudformation deploy \
            --template-file cloudformation/template.yml \
            --stack-name ${{ env.CFN_STACK_NAME }} \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --parameter-overrides \
              Environment=prod \
              LambdaFunctionName=${{ env.LAMBDA_FUNCTION_NAME }} \
            --tags \
              Environment=prod \
              Owner=beastleohfslilly \
              Project=open-meteo-weather \
              CostCenter=engineering \
            --no-fail-on-empty-changeset
          echo "âœ… Stack deployed!"

      - name: Get Stack Outputs
        id: get-outputs
        run: |
          echo "ğŸ” Reading stack outputs..."

          FUNCTION_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.CFN_STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='LambdaFunctionName'].OutputValue" \
            --output text)

          BUCKET_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.CFN_STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='BucketName'].OutputValue" \
            --output text)

          if [ -z "$FUNCTION_NAME" ] || [ "$FUNCTION_NAME" == "None" ]; then
            echo "âš ï¸ Stack output empty â€” using env fallback"
            FUNCTION_NAME="${{ env.LAMBDA_FUNCTION_NAME }}"
          fi

          echo "âœ… Lambda : $FUNCTION_NAME"
          echo "âœ… Bucket : $BUCKET_NAME"
          echo "function_name=$FUNCTION_NAME" >> $GITHUB_OUTPUT
          echo "bucket_name=$BUCKET_NAME"     >> $GITHUB_OUTPUT

      - name: Download Pandas Layer from S3
        run: |
          echo "ğŸ“¥ Downloading pandas layer..."
          aws s3 cp \
            s3://open-meteo-layers-bk1/pandas_layer.zip \
            pandas_layer.zip
          ls -lh pandas_layer.zip
          echo "âœ… Layer downloaded!"

      - name: Publish Pandas Layer
        id: publish-layer
        run: |
          echo "ğŸ“¤ Publishing pandas layer to Lambda..."
          LAYER_ARN=$(aws lambda publish-layer-version \
            --layer-name pandas-layer \
            --zip-file fileb://pandas_layer.zip \
            --compatible-runtimes python3.11 \
            --query 'LayerVersionArn' \
            --output text)

          echo "âœ… Layer ARN: $LAYER_ARN"
          echo "layer_arn=$LAYER_ARN" >> $GITHUB_OUTPUT

      - name: Attach Layer to Lambda
        run: |
          echo "ğŸ”— Attaching pandas layer to Lambda..."
          aws lambda update-function-configuration \
            --function-name ${{ steps.get-outputs.outputs.function_name }} \
            --layers ${{ steps.publish-layer.outputs.layer_arn }}

          aws lambda wait function-updated \
            --function-name ${{ steps.get-outputs.outputs.function_name }}
          echo "âœ… Layer attached!"

      - name: Package Lambda Code
        run: |
          echo "ğŸ“¦ Packaging Lambda code (no deps â€” pandas is in layer)..."
          mkdir -p package
          cp api_extractor/app_api_extractor.py package/
          cp csv_extractor/app_csv_extractor.py package/
          cd package && zip -r ../function.zip .
          ls -lh ../function.zip
          echo "âœ… Code packaged!"

      - name: Upload Lambda Code via S3
        run: |
          echo "â¬†ï¸ Uploading Lambda code..."
          ZIP_NAME=function-${{ github.sha }}.zip

          aws s3 cp function.zip \
            s3://${{ steps.get-outputs.outputs.bucket_name }}/$ZIP_NAME

          aws lambda update-function-code \
            --function-name ${{ steps.get-outputs.outputs.function_name }} \
            --s3-bucket ${{ steps.get-outputs.outputs.bucket_name }} \
            --s3-key $ZIP_NAME

          aws lambda wait function-updated \
            --function-name ${{ steps.get-outputs.outputs.function_name }}
          echo "âœ… Lambda code updated successfully!"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # JOB 3: Invoke Lambda & Download Parquet
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  invoke-and-download:
    name: Invoke Lambda & Get Output
    runs-on: ubuntu-latest
    needs: deploy-lambda

    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get Bucket Name from Stack
        id: get-bucket
        run: |
          BUCKET_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.CFN_STACK_NAME }} \
            --query "Stacks[0].Outputs[?OutputKey=='BucketName'].OutputValue" \
            --output text)

          echo "Bucket: $BUCKET_NAME"
          echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT

      - name: Invoke Lambda Function
        id: invoke
        run: |
          echo "ğŸš€ Invoking Lambda..."
          aws lambda invoke \
            --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
            --payload '{}' \
            --cli-binary-format raw-in-base64-out \
            response.json

          echo "Lambda response:"
          cat response.json

          S3_KEY=$(python3 -c "
          import json
          body = json.load(open('response.json'))
          print(json.loads(body['body'])['s3_key'])
          ")
          echo "s3_key=$S3_KEY" >> $GITHUB_OUTPUT
          echo "âœ… Output saved to S3: $S3_KEY"

      - name: Download Output from S3
        run: |
          mkdir -p output
          aws s3 cp \
            s3://${{ steps.get-bucket.outputs.bucket_name }}/${{ steps.invoke.outputs.s3_key }} \
            output/result.parquet
          echo "âœ… Downloaded: output/result.parquet"

      - name: Upload as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: weather-output-parquet
          path: output/result.parquet
          retention-days: 30